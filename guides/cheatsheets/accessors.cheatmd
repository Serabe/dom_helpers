# Accessors Cheatsheet

Accessors let you access certains parts of the element you have selected previously.
As the given htmlable can contain multiple nodes, these functions return lists.

## Selecting nodes
{: .col-2}

#### All matching nodes

```elixir
find(view, "p")
# Returns all paragraphs.
```

#### First matching node

```elixir
find_first(view, "div.contents")
# Returns the first div with contents class
```

#### Count the matching nodes

Just a convinience function.

```elixir
find_count(view, "p")
# Counts the number of paragraphs

find_count(view, "nav ul li")
# Counts the number of elements in the navigation list
```

## Selecting attributes
{: .col-2}

### Classes

Classes are quite common in HTML. Specially useful when checking for classes like
`hidden` in Tailwind, that checks if an element should be hidden or not. Class
attributes will be split in words before being returned.

#### One element

Look out for the nested list!

```elixir
classes(~s[<div class="one two three">Content</div>])
# [["one", "two", "three"]]
```

#### Several elements

```elixir
classes(~s[<div class="one two three">Content</div><div class="four five">Other</div>])
# [["one", "two", "three"], ["four", "five"]]
```

#### Using selectors
`classes/2` let's you pass a selector as second argument. This is convenient so you don't
to pipe `find` just for this.

```elixir
classes(~s[<div class="one two three">Content</div><div class="first">Other</div>], ".one")
# [["one", "two", "three"]]
classes(~s[<div class="one two three">Content</div><div class="four five">Other</div>], "div")
# [["one", "two", "three"], ["four", "five"]]
```

### Other attributes

Other attributes can easily be accessed too. Unlike classes, these values are returned
as strings, unparsed in any way.

#### One element

```elixir
attribute(~s[<li data-index="0">1</li>], "data-index")
# ["0"]
```

#### Several elements

```elixir
attribute(~s[<li data-index="0">1</li><li data-index="1">2</li>], "data-index")
# ["0", "1"]
```

#### Using selectors

`attribute/3` let's you pass a selector as second argument. This is convenient so you don't
to pipe `find` just for this.


```elixir
attribute(~s[<div class="one" data-index="0">Content</div><div class="first" data-index="1">Other</div>], ".one", "data-index")
# ["0"]
attribute(~s[<div class="one two three">Content</div><div class="four five">Other</div>], "div", "class")
# ["one two three", "four five"]
```

### Text

#### Several elements, combined

Text would return just one string for all elements by default.

```elixir
text(~s(<ul><li class="odd"> First </li> <li class="even"> Second </li> <li class="odd"> Third </li></ul>), ".odd")
# "First Third"

text(~s(<ul><li class="odd"> First </li> <li class="even"> Second </li> <li class="odd"> Third </li></ul>), ".even")
# "Second"

text(~s(<ul><li class="odd"> First </li> <li class="even"> Second </li> <li class="odd"> Third </li></ul>), ".none")
# ""

text(~s(<ul><li class="odd"> First </li> <li class="even"> Second </li> <li class="odd"> Third </li></ul>), "li")
# "First Second Third"
```

#### Several elements, list

Combine `Enum.map/2` with `Nobs.Accessors.text/3` to create a list.

```elixir
find(~s(<ul><li class="odd"> First </li> <li class="even"> Second </li> <li class="odd"> Third </li></ul>), "li") |> Enum.map(&text/1)
# ~w(First Second Third)
```